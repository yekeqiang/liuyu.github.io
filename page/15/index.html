<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 15 页 | Liuyu's blog</title>
  <meta name="author" content="Liu Yu">
  
  <meta name="description" content="Puppet cdn AutoMate">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Liuyu's blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Liuyu's blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Liuyu's blog</a></h1>
  <h2><a href="/">Puppet in action</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
    <li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-12-18T22:50:14.000Z"><a href="/2010/12/19/linux-allcommands-1/">12月 19 2010</a></time>
      
      
  
    <h1 class="title"><a href="/2010/12/19/linux-allcommands-1/">linux系统管理技巧(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文来自： allcommands
整理其比较实用的好的程序，并翻译过来。</p>
<p>一、在当前目录及子目录下搜索所有后缀为 .php 的文件，并且将 字符串 baidu.com 替换成 opendoc.com.cn</p>
<pre><code><figure class="highlight"><pre>find -name *.php |xargs perl -pi -e <span class="string">'s|baidu.com|opendoc.com.cn|g'</span>;
sed -i <span class="string">"s/baidu.com/opendoc.com.cn/g"</span> `grep baidu.com -rl ./``&lt;/pre&gt;

二、将当前目录文件名全部转换成小写
&lt;pre&gt;`<span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> mv <span class="string">"$i"</span> <span class="string">"$(echo $i|tr A-Z a-z)"</span>; done`&lt;/pre&gt;

三、查找二个文件相同的内容
&lt;pre&gt;`grep -Fx -f file1 file2
sort file1 file2 | uniq -d`&lt;/pre&gt;

四、查找file2里 file1里没有的内容
&lt;pre&gt;`grep -Fxv -f file1 file2`&lt;/pre&gt;

五、自动更新SVN的一个目录
&lt;pre&gt;`<span class="keyword">for</span> d <span class="keyword">in</span> $(find . -maxdepth <span class="number">1</span> -<span class="built_in">type</span> d -name <span class="string">'[^.]*'</span>); <span class="keyword">do</span> cd <span class="string">"$d"</span>; svn up; cd ..; done`&lt;/pre&gt;

六、查找当前文件列表 文件与组没有修改时间排序
&lt;pre&gt;`find . -<span class="built_in">type</span> f | xargs ls -ltrhg
l: 所有信息
t: 修改时间排序
r: 倒序
h: 大小 M K
g: 用户组`&lt;/pre&gt;

七、找到文件，将其与一个可读的信息输出列表
&lt;pre&gt;`find . -<span class="built_in">type</span> f | sed <span class="string">'s,.*,stat "&amp;" | egrep "File|Modify" | tr "\\n" " " ; echo ,'</span> | sh | sed <span class="string">'s,[^/]*/\(.*\). Modify: \(....-..-.. ..:..:..\).*,\2 \1,'</span> | sort
find . -<span class="built_in">type</span> f -exec ls -tr {} +
find . -<span class="built_in">type</span> f | sed <span class="string">'s,.*,stat "&amp;" | egrep "File|Modify" | tr "\\n" " " ; echo ,'</span> | sh | sed <span class="string">'s,[^/]*/\(.*\). Modify: \(...........\).*,\2 \1,'</span> | sort
ls -rl <span class="comment">--time-style=+%s * | sed '/^$/,/^total [0-9]*$/d' | sort -nk6`&lt;/pre&gt;</span>

八、查找文件和他们按修改时间排序的列表
&lt;pre&gt;`ls -rl <span class="comment">--time-style=+%s * | sed '/^$/,/^total [0-9]*$/d' | sort -nk6`&lt;/pre&gt;</span>

九、查找N天前的文件，按时间排序
&lt;pre&gt;`find . -<span class="built_in">type</span> f -mtime -<span class="number">14</span> -exec ls -ltd \{\} \; | less`&lt;/pre&gt;

十、配置PS aliases
&lt;pre&gt;`export PSOA=<span class="string">'user,pid,time,state,command'</span> ; <span class="function"><span class="keyword">function</span> <span class="title">_ps</span> { /<span class="title">bin</span>/<span class="title">ps</span> $@ ; } ; <span class="title">alias</span> <span class="title">psa</span>='<span class="title">_ps</span> <span class="title">ax</span> -<span class="title">o</span>
$<span class="title">PSOA</span>'
#<span class="title">ps</span> <span class="title">aliases</span>
<span class="title">PSO</span>='<span class="title">user</span>,<span class="title">pid</span>,<span class="title">ppid</span>,%<span class="title">cpu</span>,%<span class="title">mem</span>,<span class="title">time</span>,<span class="title">start</span>,<span class="title">state</span>,<span class="title">command</span>'
<span class="title">PSOA</span>='<span class="title">user</span>,<span class="title">pid</span>,<span class="title">time</span>,<span class="title">state</span>,<span class="title">command</span>'
<span class="title">PSOL</span>='<span class="title">user</span>,<span class="title">pid</span>,<span class="title">ppid</span>,%<span class="title">cpu</span>,%<span class="title">mem</span>,<span class="title">nice</span>,<span class="title">pri</span>,<span class="title">etime</span>,<span class="title">time</span>,<span class="title">tt</span>,<span class="title">state</span>,<span class="title">ucomm</span>'
<span class="title">export</span> <span class="title">PSO</span> <span class="title">PSOA</span> <span class="title">PSOL</span>
<span class="title">function</span> <span class="title">_ps</span> { /<span class="title">bin</span>/<span class="title">ps</span> $@ ; }
<span class="title">alias</span> <span class="title">ps</span>='<span class="title">_ps</span> <span class="title">ax</span> -<span class="title">o</span> $<span class="title">PSO</span>'
<span class="title">alias</span> <span class="title">psa</span>='<span class="title">_ps</span> <span class="title">ax</span> -<span class="title">o</span> $<span class="title">PSOA</span>'
<span class="title">alias</span> <span class="title">psl</span>='<span class="title">_ps</span> <span class="title">ax</span> -<span class="title">o</span> $<span class="title">PSOL</span>'
<span class="title">alias</span> <span class="title">psm</span>='<span class="title">_ps</span> -<span class="title">U</span> $<span class="title">USER</span> -<span class="title">o</span> $<span class="title">PSOA</span>'
`&lt;/<span class="title">pre</span>&gt;

十一、逐渐打印各行
&lt;<span class="title">pre</span>&gt;`<span class="title">awk</span> '<span class="title">BEGIN</span>{<span class="title">ORS</span>=""}<span class="title">NR</span>!=1&amp;&amp;<span class="title">FNR</span>==1{<span class="title">print</span> "\<span class="title">n</span>"}{<span class="title">print</span>}<span class="title">END</span>{<span class="title">print</span> "\<span class="title">n</span>"}' *.<span class="title">txt</span>
</pre></figure></code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-12-18T22:47:22.000Z"><a href="/2010/12/19/linux-system-user-commands/">12月 19 2010</a></time>
      
      
  
    <h1 class="title"><a href="/2010/12/19/linux-system-user-commands/">linux系统管理员常用命令集合</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文由linuxtone.org Netseek出品
一些命令我用着不是很习惯。对系统，日志等命令进行了补充</p>
<p><strong>系统连接状态篇：</strong></p>
<p>1.查看TCP连接状态</p>
<pre><code><figure class="highlight"><pre><span class="xml">netstat -nat |awk '{print </span><span class="variable">$6}</span><span class="xml">'|sort|uniq -c|sort -rn
netstat -n | awk '/</span><span class="keyword">^tcp</span><span class="xml">/ {++S[</span><span class="variable">$NF</span><span class="xml">]};END {for(a in S) print a, S[a]}'
netstat -n | awk '/</span><span class="keyword">^tcp</span><span class="xml">/ {++state[</span><span class="variable">$NF</span><span class="xml">]}; END {for(key in state) print key,"\t",state[key]}'
netstat -n | awk '/</span><span class="keyword">^tcp</span><span class="xml">/ {++arr[</span><span class="variable">$NF</span><span class="xml">]};END {for(k in arr) print k,"\t",arr[k]}'
netstat -n |awk '/</span><span class="keyword">^tcp</span><span class="xml">/ {print </span><span class="variable">$NF}</span><span class="xml">'|sort|uniq -c|sort -rn
netstat -ant | awk '{print </span><span class="variable">$NF}</span><span class="xml">' | grep -v '[a-z]' | sort | uniq -c
netstat -ant|awk '/ip:</span><span class="number">80</span><span class="xml">/{split(</span><span class="variable">$5</span><span class="xml">,ip,":");++S[ip[</span><span class="number">1</span><span class="xml">]]}END{for (a in S) print S[a],a}' |sort -n
netstat -ant|awk '/:</span><span class="number">80</span><span class="xml">/{split(</span><span class="variable">$5</span><span class="xml">,ip,":");++S[ip[</span><span class="number">1</span><span class="xml">]]}END{for (a in S) print S[a],a}' |sort -rn|head -n </span><span class="number">10</span><span class="xml">
awk 'BEGIN{printf ("http_code\tcount_num\n")}{COUNT[</span><span class="variable">$10</span><span class="xml">]++}END{for (a in COUNT) printf a"\t\t"COUNT[a]"\n"}'
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">2.</span><span class="xml">查找请求数请</span><span class="number">20</span><span class="xml">个IP（常用于查找攻来源）：
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`netstat -anlp|grep </span><span class="number">80</span><span class="xml">|grep tcp|awk '{print </span><span class="variable">$5}</span><span class="xml">'|awk -F: '{print </span><span class="variable">$1}</span><span class="xml">'|sort|uniq -c|sort -nr|head -n20
netstat -ant |awk '/:</span><span class="number">80</span><span class="xml">/{split(</span><span class="variable">$5</span><span class="xml">,ip,":");++A[ip[</span><span class="number">1</span><span class="xml">]]}END{for(i in A) print A[i],i}' |sort -rn|head -n20
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">3.</span><span class="xml">用tcpdump嗅探</span><span class="number">80</span><span class="xml">端口的访问看看谁最高
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`tcpdump -i eth0 -tnn dst port </span><span class="number">80</span><span class="xml"> -c </span><span class="number">1000</span><span class="xml"> | awk -F"." '{print </span><span class="variable">$1</span><span class="xml">"."</span><span class="variable">$2</span><span class="xml">"."</span><span class="variable">$3</span><span class="xml">"."</span><span class="variable">$4}</span><span class="xml">' | sort | uniq -c | sort -nr |head -</span><span class="number">20</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">4.</span><span class="xml">查找较多time_wait连接
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`netstat -n|grep TIME_WAIT|awk '{print </span><span class="variable">$5}</span><span class="xml">'|sort|uniq -c|sort -rn|head -n20
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">5.</span><span class="xml">找查较多的SYN连接
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`netstat -an | grep SYN | awk '{print </span><span class="variable">$5}</span><span class="xml">' | awk -F: '{print </span><span class="variable">$1}</span><span class="xml">' | sort | uniq -c | sort -nr | more
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">6.</span><span class="xml">根据端口列进程
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`netstat -ntlp | grep </span><span class="number">80</span><span class="xml"> | awk '{print </span><span class="variable">$7}</span><span class="xml">' | cut -d/ -f1
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

**网站日志分析篇</span><span class="number">1</span><span class="xml">（Apache）**：
</span><span class="number">1.</span><span class="xml">获得访问前</span><span class="number">10</span><span class="xml">位的ip地址
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log|awk '{print </span><span class="variable">$1}</span><span class="xml">'|sort|uniq -c|sort -nr|head -</span><span class="number">10</span><span class="xml">
cat access.log|awk '{counts[$(</span><span class="number">11</span><span class="xml">)]+=</span><span class="number">1</span><span class="xml">}; END {for(url in counts) print counts[url], url}'
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">2.</span><span class="xml">访问次数最多的文件或页面,取前</span><span class="number">20</span><span class="xml">
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log|awk '{print </span><span class="variable">$11}</span><span class="xml">'|sort|uniq -c|sort -nr|head -</span><span class="number">20</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">3.</span><span class="xml">列出传输最大的几个exe文件（分析下载站的时候常用）
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '(</span><span class="variable">$7</span><span class="xml">~/\.exe/){print </span><span class="variable">$10</span><span class="xml"> " " </span><span class="variable">$1</span><span class="xml"> " " </span><span class="variable">$4</span><span class="xml"> " " </span><span class="variable">$7}</span><span class="xml">'|sort -nr|head -</span><span class="number">20</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">4.</span><span class="xml">列出输出大于</span><span class="number">200000</span><span class="xml">byte(约</span><span class="number">200</span><span class="xml">kb)的exe文件以及对应文件发生次数
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '(</span><span class="variable">$10</span><span class="xml"> &gt; </span><span class="number">200000</span><span class="xml"> &amp;&amp; </span><span class="variable">$7</span><span class="xml">~/\.exe/){print </span><span class="variable">$7}</span><span class="xml">'|sort -n|uniq -c|sort -nr|head -</span><span class="number">100</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">5.</span><span class="xml">如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '(</span><span class="variable">$7</span><span class="xml">~/\.php/){print </span><span class="variable">$NF</span><span class="xml"> " " </span><span class="variable">$1</span><span class="xml"> " " </span><span class="variable">$4</span><span class="xml"> " " </span><span class="variable">$7}</span><span class="xml">'|sort -nr|head -</span><span class="number">100</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">6.</span><span class="xml">列出最最耗时的页面(超过</span><span class="number">60</span><span class="xml">秒的)的以及对应页面发生次数
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '(</span><span class="variable">$NF</span><span class="xml"> &gt; </span><span class="number">60</span><span class="xml"> &amp;&amp; </span><span class="variable">$7</span><span class="xml">~/\.php/){print </span><span class="variable">$7}</span><span class="xml">'|sort -n|uniq -c|sort -nr|head -</span><span class="number">100</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">7.</span><span class="xml">列出传输时间超过 </span><span class="number">30</span><span class="xml"> 秒的文件
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '(</span><span class="variable">$NF</span><span class="xml"> &gt; </span><span class="number">30</span><span class="xml">){print </span><span class="variable">$7}</span><span class="xml">'|sort -n|uniq -c|sort -nr|head -</span><span class="number">20</span><span class="xml">
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">8.</span><span class="xml">统计网站流量（G)
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '{sum+=</span><span class="variable">$10}</span><span class="xml"> END {print sum/</span><span class="number">1024</span><span class="xml">/</span><span class="number">1024</span><span class="xml">/</span><span class="number">1024</span><span class="xml">}'
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">9.</span><span class="xml">统计</span><span class="number">404</span><span class="xml">的连接
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`awk '(</span><span class="variable">$9</span><span class="xml"> ~/</span><span class="number">404</span><span class="xml">/)' access.log | awk '{print </span><span class="variable">$9</span><span class="xml">,</span><span class="variable">$7}</span><span class="xml">' | sort
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">10</span><span class="xml">\. 统计http status.
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '{counts[$(</span><span class="number">9</span><span class="xml">)]+=</span><span class="number">1</span><span class="xml">}; END {for(code in counts) print code, counts[code]}'
cat access.log |awk '{print </span><span class="variable">$9}</span><span class="xml">'|sort|uniq -c|sort -rn
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">11.</span><span class="xml">每秒并发：
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`awk '{if(</span><span class="variable">$9</span><span class="xml">~/</span><span class="number">200</span><span class="xml">|</span><span class="number">30</span><span class="xml">|</span><span class="number">404</span><span class="xml">/)COUNT[</span><span class="variable">$4</span><span class="xml">]++}END{for( a in COUNT) print a,COUNT[a]}'|sort -k </span><span class="number">2</span><span class="xml"> -nr|head -n10
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">12.</span><span class="xml">带宽统计
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat apache.log |awk '{if(</span><span class="variable">$7</span><span class="xml">~/GET/) count++}END{print "client_request="count}'
cat apache.log |awk '{BYTE+=</span><span class="variable">$11}</span><span class="xml">END{print "client_kbyte_out="BYTE/</span><span class="number">1024</span><span class="xml">"KB"}'
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">13.</span><span class="xml">统计对象数量及对象平均大小
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`cat access.log |awk '{byte+=</span><span class="variable">$10}</span><span class="xml">END{ print byte/NR/</span><span class="number">1024</span><span class="xml">,NR}'
cat access.log |awk '{if(</span><span class="variable">$9</span><span class="xml">~/</span><span class="number">200</span><span class="xml">|</span><span class="number">30</span><span class="xml">/)COUNT[</span><span class="variable">$NF</span><span class="xml">]++}END{for( a in COUNT) print a,COUNT
[a],NR,COUNT[a]/NR*</span><span class="number">100</span><span class="xml">"%"}
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">14.</span><span class="xml">取</span><span class="number">5</span><span class="xml">分钟日志
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`if [ </span><span class="variable">$DATE_MINUTE</span><span class="xml"> != </span><span class="variable">$DATE_END_MINUTE</span><span class="xml"> ] ;then #则判断开始时间戳与结束时间戳是否相等
START_LINE=`sed -n "/</span><span class="variable">$DATE_MINUTE</span><span class="xml">/=" </span><span class="variable">$APACHE_LOG</span><span class="xml">|head -n1` #如果不相等，则取出开始时间戳的行号，与结束时间戳的行号
</span><span class="comment">#END_LINE=`sed -n "/$DATE_END_MINUTE/=" $APACHE_LOG|tail -n1`</span><span class="xml">
END_LINE=`sed -n "/</span><span class="variable">$DATE_END_MINUTE</span><span class="xml">/=" </span><span class="variable">$APACHE_LOG</span><span class="xml">|head -n1`
sed -n "</span><span class="variable">${START_LINE}</span><span class="xml">,</span><span class="variable">${END_LINE}</span><span class="xml">p" </span><span class="variable">$APACHE_LOG</span><span class="xml"> &gt; </span><span class="variable">$MINUTE_LOG</span><span class="xml"> ##通过行号，取出</span><span class="number">5</span><span class="xml">分钟内的日志内容 存放到 临时文件中
GET_START_TIME=`sed -n "</span><span class="variable">${START_LINE}</span><span class="xml">p" </span><span class="variable">$APACHE_LOG</span><span class="xml">|awk -F '[' '{print </span><span class="variable">$2}</span><span class="xml">' |awk '{print </span><span class="variable">$1}</span><span class="xml">'|
sed 's#/# #g'|sed 's#:# #'` #通过行号获取取出开始时间戳
GET_END_TIME=`sed -n "</span><span class="variable">${END_LINE}</span><span class="xml">p" </span><span class="variable">$APACHE_LOG</span><span class="xml">|awk -F '[' '{print </span><span class="variable">$2}</span><span class="xml">' |awk '{print </span><span class="variable">$1}</span><span class="xml">'|sed
's#/# #g'|sed 's#:# #'` #通过行号获取结束时间戳
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

</span><span class="number">10.</span><span class="xml">蜘蛛分析
查看是哪些蜘蛛在抓取内容。
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`/usr/sbin/tcpdump -i eth0 -l -s </span><span class="number">0</span><span class="xml"> -w - dst port </span><span class="number">80</span><span class="xml"> | strings | grep -i user-agent | grep -i -E 'bot|crawler|slurp|spider'
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

**网站日分析</span><span class="number">2</span><span class="xml">(Squid篇）**
</span><span class="number">2.</span><span class="xml">按域统计流量
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`zcat squid_access.log.tar.gz| awk '{print </span><span class="variable">$10</span><span class="xml">,</span><span class="variable">$7}</span><span class="xml">' |awk 'BEGIN{FS="[ /]"}{trfc[</span><span class="variable">$4</span><span class="xml">]+=</span><span class="variable">$1}</span><span class="xml">END{for
(domain in trfc){printf "%s\t%d\n",domain,trfc[domain]}}'
效率更高的perl版本请到此下载:http://docs.linuxtone.org/soft/tools/tr.pl
`<span class="tag">&lt;/<span class="title">pre</span>&gt;</span>

**数据库篇**
</span><span class="number">1.</span><span class="xml">查看数据库执行的sql
<span class="tag">&lt;<span class="title">pre</span>&gt;</span>`/usr/sbin/tcpdump -i eth0 -s </span><span class="number">0</span><span class="xml"> -l -w - dst port </span><span class="number">3306</span><span class="xml"> | strings | egrep -i 'SELECT|UPDATE|DELETE|INSERT|SET|COMMIT|ROLLBACK|CREATE|DROP|ALTER|CALL'</span>
</pre></figure></code></pre>
<p><strong>系统Debug分析篇</strong>
1.调试命令
strace -p pid
2.跟踪指定进程的PID
gdb -p pid
更多的请参考：
<a href="http://bbs.linuxtone.org/forum-14-1.html">http://bbs.linuxtone.org/forum-14-1.html</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-12-18T20:23:16.000Z"><a href="/2010/12/19/top-20-mysql-best-practices/">12月 19 2010</a></time>
      
      
  
    <h1 class="title"><a href="/2010/12/19/top-20-mysql-best-practices/">MySQL性能优化的最佳20+条经验</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今 天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员 需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的 SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。
<strong>1. 为查询缓存优化你的查询</strong>
大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。
这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：</p>
<pre><code><figure class="highlight"><pre> // 查询缓存不开启
 $r = mysql_query("<span class="operator"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> signup_date &amp;gt;</span>= CURDATE()");
 // 开启查询缓存
 $today = date("Y-m-d");
 $r = mysql_query("<span class="operator"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> signup_date &amp;gt;</span>= '$today'");`&lt;/pre&gt;
上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而 开启缓存。

**2\. EXPLAIN 你的 <span class="operator"><span class="keyword">SELECT</span> 查询**
使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的<span class="keyword">SQL</span>语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。
EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。
挑一个你的<span class="keyword">SELECT</span>语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：

[![](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/explain.jpg <span class="string">"explain"</span>)](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/explain.jpg)

当我们为 group_id 字段加上索引后：

[![](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/groud.jpg <span class="string">"groud"</span>)](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/groud.jpg)

我们可以看到，前一个结果显示搜索了 <span class="number">7883</span> 行，而后一个只是搜索了两个表的 <span class="number">9</span> 和 <span class="number">16</span> 行。查看<span class="keyword">rows</span>列可以让我们找到潜在的性能问题。
**<span class="number">3</span>\. 当只要一行数据时使用 LIMIT <span class="number">1</span>**
当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去<span class="keyword">fetch</span>游标，或是你也许会去检查返回的记录数。
在这种情况下，加上 LIMIT <span class="number">1</span> 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。
下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是<span class="keyword">Select</span> *，第二条是<span class="keyword">Select</span> <span class="number">1</span>）
&lt;pre&gt;<span class="string">` // 没有效率的：
 $r = mysql_query("SELECT * FROM user WHERE country = 'China'");
 if (mysql_num_rows($r) &amp;gt; 0) {
 // ...
 }

 // 有效率的：
 $r = mysql_query("SELECT 1 FROM user WHERE country = 'China' LIMIT 1");
 if (mysql_num_rows($r) &amp;gt; 0) {
 // ...
 } `</span>&lt;/pre&gt;
**<span class="number">4</span>\. 为搜索字段建索引**
索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。

[![](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/<span class="number">4.</span>jpg <span class="string">"4"</span>)](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/<span class="number">4.</span>jpg)

从上图你可以看到那个搜索字串 “last_name <span class="keyword">LIKE</span> ‘a%’”，一个是建了索引，一个是没有索引，性能差了<span class="number">4</span>倍左右。
另外， 你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “<span class="keyword">WHERE</span> post_content <span class="keyword">LIKE</span> ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）
<span class="number">5</span>\. 在<span class="keyword">Join</span>表的时候使用相当类型的例，并将其索引
如果你的应用程序有很多 <span class="keyword">JOIN</span> 查询，你应该确认两个表中<span class="keyword">Join</span>的字段是被建过索引的。这样，MySQL内部会启动为你优化<span class="keyword">Join</span>的<span class="keyword">SQL</span>语句的机制。
而且，这些被用来<span class="keyword">Join</span>的字段，应该是相同的类型的。例如：如果你要把 <span class="keyword">DECIMAL</span> 字段和一个 <span class="keyword">INT</span> 字段<span class="keyword">Join</span>在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）
&lt;pre&gt;<span class="string">` // 在state中查找company
 $r = mysql_query("SELECT company_name FROM users
 LEFT JOIN companies ON (users.state = companies.state)
 WHERE users.id = $user_id");
 // 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。`</span>&lt;/pre&gt;
**<span class="number">6</span>\. 千万不要 <span class="keyword">ORDER</span> <span class="keyword">BY</span> RAND()**
想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。
如果 你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行 RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit <span class="number">1</span>也无济于事（因为要排序）
下面的示例是随机挑一条记录
&lt;pre&gt;<span class="string">` // 千万不要这样做：
 $r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1");

 // 这要会更好：
 $r = mysql_query("SELECT count(*) FROM user");
 $d = mysql_fetch_row($r);
 $rand = mt_rand(0,$d[0] - 1);

 $r = mysql_query("SELECT username FROM user LIMIT $rand, 1");`</span>&lt;/pre&gt;
**<span class="number">7</span>\. 避免 <span class="keyword">SELECT</span> ***
从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。
所以，你应该养成一个需要什么就取什么的好的习惯。
&lt;pre&gt;<span class="string">` // 不推荐
 $r = mysql_query("SELECT * FROM user WHERE user_id = 1");
 $d = mysql_fetch_assoc($r);
 echo "Welcome {$d['username']}";

 // 推荐
 $r = mysql_query("SELECT username FROM user WHERE user_id = 1");
 $d = mysql_fetch_assoc($r);
 echo "Welcome {$d['username']}";`</span>&lt;/pre&gt;
**<span class="number">8</span>\. 永远为每张表设置一个ID**
我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个<span class="keyword">INT</span>型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。
就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 <span class="keyword">VARCHAR</span> 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。
而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……
在 这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一 个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫 “外键”其共同组成主键。

**<span class="number">9</span>\. 使用 ENUM 而不是 <span class="keyword">VARCHAR</span>**
ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。
如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 <span class="keyword">VARCHAR</span>。
MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 <span class="keyword">VARCHAR</span> 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 <span class="keyword">PROCEDURE</span> ANALYSE() 你可以得到相关的建议。

**<span class="number">10</span>\. 从 <span class="keyword">PROCEDURE</span> ANALYSE() 取得建议**
<span class="keyword">PROCEDURE</span> ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。
例 如，如果你创建了一个 <span class="keyword">INT</span> 字段作为你的主键，然而并没有太多的数据，那么，<span class="keyword">PROCEDURE</span> ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 <span class="keyword">VARCHAR</span> 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。
在phpmyadmin里，你可以在查看表时，点击 “Propose <span class="keyword">table</span> structure” 来查看这些建议

[![](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/<span class="number">10.</span>jpg <span class="string">"10"</span>)](http://bubbyroom.com/wp-content/uploads/<span class="number">2010</span>/<span class="number">12</span>/<span class="number">10.</span>jpg)

一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。

**<span class="number">11</span>\. 尽可能的使用 <span class="keyword">NOT</span> <span class="keyword">NULL</span>**
除非你有一个很特别的原因去使用 <span class="keyword">NULL</span> 值，你应该总是让你的字段保持 <span class="keyword">NOT</span> <span class="keyword">NULL</span>。这看起来好像有点争议，请往下看。
首先，问问你自己“Empty”和“<span class="keyword">NULL</span>”有多大的区别（如果是<span class="keyword">INT</span>，那就是<span class="number">0</span>和<span class="keyword">NULL</span>）？如果你觉得它们之间没有什么区别，那么你就不要使用<span class="keyword">NULL</span>。（你知道吗？在 Oracle 里，<span class="keyword">NULL</span> 和 Empty 的字符串是一样的！)
不要以为 <span class="keyword">NULL</span> 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用<span class="keyword">NULL</span>了，现实情况是很复杂的，依然会有些情况下，你需要使用<span class="keyword">NULL</span>值。
下面摘自MySQL自己的文档：
“<span class="keyword">NULL</span> columns require additional <span class="keyword">space</span> <span class="keyword">in</span> the row <span class="keyword">to</span> record whether their <span class="keyword">values</span> <span class="keyword">are</span> <span class="keyword">NULL</span>. <span class="keyword">For</span> MyISAM tables, each <span class="keyword">NULL</span> <span class="keyword">column</span> takes one <span class="keyword">bit</span> extra, rounded up <span class="keyword">to</span> the nearest byte.”

**<span class="number">12</span>\. Prepared Statements**
Prepared Statements很像存储过程，是一种运行在后台的<span class="keyword">SQL</span>语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。
Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“<span class="keyword">SQL</span>注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题， 而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。
在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。
虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。
当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本<span class="number">5.1</span>后支持了。
在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如： PDO.
&lt;pre&gt;<span class="string">` // 创建 prepared statement
 if ($stmt = $mysqli-&amp;gt;prepare("SELECT username FROM user WHERE state=?")) {

 // 绑定参数
 $stmt-&amp;gt;bind_param("s", $state);

 // 执行
 $stmt-&amp;gt;execute();

 // 绑定结果
 $stmt-&amp;gt;bind_result($username);

 // 移动游标
 $stmt-&amp;gt;fetch();

 printf("%s is from %s\n", $username, $state);

 $stmt-&amp;gt;close();
 }`</span>&lt;/pre&gt;
**<span class="number">13</span>\. 无缓冲的查询**
正常的情况下，当你在当你在你的脚本中执行一个<span class="keyword">SQL</span>语句的时候，你的程序会停在那里直到没这个<span class="keyword">SQL</span>语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。
关于这个事情，在PHP的文档中有一个非常不错的说明： mysql_unbuffered_query() 函数：
“mysql_unbuffered_query() sends the <span class="keyword">SQL</span> query query <span class="keyword">to</span> MySQL without automatically fetching <span class="keyword">and</span> buffering the result <span class="keyword">rows</span> <span class="keyword">as</span> mysql_query() does. This saves a considerable amount <span class="keyword">of</span> memory <span class="keyword">with</span> <span class="keyword">SQL</span> queries that produce large result sets, <span class="keyword">and</span> you can <span class="keyword">start</span> working <span class="keyword">on</span> the result <span class="keyword">set</span> immediately after the <span class="keyword">first</span> row has been retrieved <span class="keyword">as</span> you don’t have <span class="keyword">to</span> wait until the complete <span class="keyword">SQL</span> query has been performed.”
上面那句话翻译过来是 说，mysql_unbuffered_query() 发送一个<span class="keyword">SQL</span>语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大 量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。
然而，这会 有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用 mysql_free_result() 清除结果。而且， mysql_num_rows() 或 mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。
** **

**<span class="number">14</span>\. 把IP地址存成 UNSIGNED <span class="keyword">INT</span>**
很多程序员都会创建一个 <span class="keyword">VARCHAR</span>(<span class="number">15</span>) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要<span class="number">4</span>个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当 你需要使用这样的<span class="keyword">WHERE</span>条件：IP between ip1 <span class="keyword">and</span> ip2。
我们必需要使用UNSIGNED <span class="keyword">INT</span>，因为 IP地址会使用整个<span class="number">32</span>位的无符号整形。
而你的查询，你可以使用 INET_ATON() 来把一个字符串IP转成一个整形，并使用 INET_NTOA() 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 ip2long() 和 long2ip()。
<span class="number">1</span> $r = <span class="string">"UPDATE users SET ip = INET_ATON('{$_SERVER['REMOTE_ADDR']}') WHERE user_id = $user_id"</span>;</span>

**15\. 固定长度的表会更快**
如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。
固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。
并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。
使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。

**16\. 垂直分割**
“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）
示 例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字 段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有 好的性能。
示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户 ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。
另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。

**17\. 拆分大的 <span class="operator"><span class="keyword">DELETE</span> 或 <span class="keyword">INSERT</span> 语句**
如果你需要在一个在线的网站上去执行一个大的 <span class="keyword">DELETE</span> 或 <span class="keyword">INSERT</span> 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。
Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。
如果你把你的表锁上一段时间，比如<span class="number">30</span>秒钟，那么对于一个有很高访问量的站点来说，这<span class="number">30</span>秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。
所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：
&lt;pre&gt;<span class="string">` while (1) {
 //每次只做1000条
 mysql_query("DELETE FROM logs WHERE log_date &amp;lt;= '2009-11-01' LIMIT 1000");
 if (mysql_affected_rows() == 0) {
 // 没得可删了，退出！
 break;
 }
 // 每次都要休息一会儿
 usleep(50000);
 }
</pre></figure></code></pre>
<p><strong>18. 越小的列会越快</strong>
对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。
参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。
如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。
当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。</p>
<p><strong>19. 选择正确的存储引擎</strong>
在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。
MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都 无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。
InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。
下面是MySQL的手册
target=”_blank”MyISAM Storage Engine
InnoDB Storage Engine</p>
<p>20. 使用一个对象关系映射器（Object Relational Mapper）
使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。
ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。
ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。
目前，个人最喜欢的PHP的ORM是：Doctrine。
<strong>21. 小心“永久链接”</strong>
“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们 的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。</p>
<p>PHP手册：mysql_pconnect()
在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。
而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。
（全文完）
转帖自：<a href="http://www.oschina.net/bbs/thread/9917">http://www.oschina.net/bbs/thread/9917</a>
<a href="http://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/">http://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-12-18T06:13:39.000Z"><a href="/2010/12/18/mysql-optimization/">12月 18 2010</a></time>
      
      
  
    <h1 class="title"><a href="/2010/12/18/mysql-optimization/">Mysql编译参数优化</a></h1>
  

    </header>
    <div class="entry">
      
        <p><strong>1. -static 13%</strong></p>
<pre><code><figure class="highlight"><pre><span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">client</span>-<span class="comment">ldflags=</span>-<span class="comment">all</span>-<span class="comment">static</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">mysqld</span>-<span class="comment">ldflags=</span>-<span class="comment">all</span>-<span class="comment">static</span>
<span class="comment">`</span>&lt;<span class="comment">/pre</span>&gt;
<span class="comment">静态链接提高13%性能</span>

<span class="comment">**2\</span>. <span class="literal">-</span><span class="comment">pgcc</span> <span class="comment">1%**</span>

&lt;<span class="comment">pre</span>&gt;<span class="comment">`CFLAGS="</span>-<span class="comment">O3</span> <span class="literal">-</span><span class="comment">mpentiumpro</span> <span class="literal">-</span><span class="comment">mstack</span>-<span class="comment">align</span>-<span class="comment">double"</span> <span class="comment">CXX=gcc</span> <span class="comment">\</span>
<span class="comment">CXXFLAGS="</span>-<span class="comment">O3</span> <span class="literal">-</span><span class="comment">mpentiumpro</span> <span class="literal">-</span><span class="comment">mstack</span>-<span class="comment">align</span>-<span class="comment">double</span> <span class="comment">\</span>
<span class="literal">-</span><span class="comment">felide</span>-<span class="comment">constructors</span> <span class="literal">-</span><span class="comment">fno</span>-<span class="comment">exceptions</span> <span class="literal">-</span><span class="comment">fno</span>-<span class="comment">rtti"</span>
<span class="comment">`</span>&lt;<span class="comment">/pre</span>&gt;

<span class="comment">如果是Inter处理器，使用pgcc提高1%性能</span>
<span class="comment">**</span>
<span class="comment">3\</span>. <span class="comment">Unix</span> <span class="comment">Socket</span> <span class="comment">7</span>.<span class="comment">5%**</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">unix</span>-<span class="comment">socket</span>-<span class="comment">path=/usr/local/mysql/tmp/mysql</span>.<span class="comment">sock</span>
<span class="comment">使用unix套接字链接提高7</span>.<span class="comment">5%性能，所以在windows下mysql性能肯定不如unix下面</span>

<span class="comment">**4\</span>. <span class="literal">-</span><span class="literal">-</span><span class="comment">enable</span>-<span class="comment">assembler**</span>
<span class="comment">允许使用汇编模式(优化性能)</span>
<span class="comment">下面是总体的编译文件</span>
<span class="comment">编译代码</span>
&lt;<span class="comment">pre</span>&gt;<span class="comment">`CFLAGS="</span>-<span class="comment">O3"</span> <span class="comment">CXX=gcc</span> <span class="comment">CXXFLAGS="</span>-<span class="comment">O3</span> <span class="literal">-</span><span class="comment">felide</span>-<span class="comment">constructors</span> <span class="comment">\</span>
<span class="literal">-</span><span class="comment">fno</span>-<span class="comment">exceptions</span> <span class="literal">-</span><span class="comment">fno</span>-<span class="comment">rtti</span> <span class="literal">-</span><span class="comment">fomit</span>-<span class="comment">frame</span>-<span class="comment">pointer</span> <span class="literal">-</span><span class="comment">ffixed</span>-<span class="comment">ebp"</span>
<span class="string">.</span><span class="comment">/configure</span> <span class="comment">\</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">prefix=/usr/local/mysql</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">enable</span>-<span class="comment">assembler</span> <span class="comment">\</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">mysqld</span>-<span class="comment">ldflags=</span>-<span class="comment">all</span>-<span class="comment">static</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">client</span>-<span class="comment">ldflags=</span>-<span class="comment">all</span>-<span class="comment">static</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">unix</span>-<span class="comment">socket</span>-<span class="comment">path=/usr/local/mysql/tmp/mysql</span>.<span class="comment">sock</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">charset=utf8</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">collation=utf8_general_ci</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">with</span>-<span class="comment">extra</span>-<span class="comment">charsets=all
</pre></figure></code></pre>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2010-12-18T06:05:34.000Z"><a href="/2010/12/18/vsftpd-virtual-user/">12月 18 2010</a></time>
      
      
  
    <h1 class="title"><a href="/2010/12/18/vsftpd-virtual-user/">vsftpd 安装与虚拟用户配置</a></h1>
  

    </header>
    <div class="entry">
      
        <p>vsftpd 安装与虚拟用户配置</p>
<p>测试环境：
centos 5.X 64bit
vsftpd 2.0</p>
<p>安装：yum -y install vsftpd</p>
<p>需求：
虚拟三个用户，使用同一个家目录。权限如下。
ftpadmin 读写删除
ftpuser 读写
ftp 读(下载)
目录为：/data
密码统一为：123456</p>
<p>一、创建虚拟用户数据库：
1、创建文件文件loginuser.txt
格式如下：</p>
<pre><code><figure class="highlight"><pre><span class="title">user_id</span>
<span class="title">password</span>
/home/loginuser.txt
<span class="title">ftpadmin</span>
<span class="number">123456</span>
<span class="title">ftpuser</span>
<span class="number">123456</span>
<span class="title">ftp</span>
<span class="number">123456</span>
`&lt;/pre&gt;
<span class="number">2</span>、生成数据库文件：

<span class="title">yum</span> -y install db4-utils
&lt;pre&gt;`
<span class="title">db_load</span> -<span class="type">T</span> -t hash -f /home/loginuser.txt /etc/vsftpd/vsftpd_login.db
<span class="title">chmod</span> <span class="number">600</span> /etc/vsftpd/vsftpd_login.db
`&lt;/pre&gt;
<span class="number">3</span>、配置pam文件
# vi /etc/pam.d/vsftpd.vu
&lt;pre&gt;`auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login
<span class="title">account</span> required /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login
`&lt;/pre&gt;
#<span class="number">32</span>位操作系统
&lt;pre&gt;`auth required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login
<span class="title">account</span> required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login
`&lt;/pre&gt;
二、为虚拟用户创建本地系统用户
&lt;pre&gt;`useradd opendoc -d /<span class="typedef"><span class="keyword">data</span> -s /bin/false</span>
<span class="title">chown</span> opendoc.opendoc /<span class="typedef"><span class="keyword">data</span></span>
`&lt;/pre&gt;
三、vsftpd.conf配置
&lt;pre&gt;`anonymous_enable=<span class="type">NO</span>
<span class="title">local_enable</span>=<span class="type">YES</span>
#write_enable=<span class="type">NO</span>
<span class="title">dirmessage_enable</span>=<span class="type">YES</span>
<span class="title">xferlog_enable</span>=<span class="type">YES</span>
<span class="title">xferlog_file</span>=/var/log/vsftpd.log
<span class="title">connect_from_port_20</span>=<span class="type">YES</span>
<span class="title">xferlog_std_format</span>=<span class="type">YES</span>
<span class="title">listen</span>=<span class="type">YES</span>
<span class="title">listen_port</span>=<span class="number">21</span>
<span class="title">userlist_enable</span>=<span class="type">YES</span>
<span class="title">chroot_local_user</span>=<span class="type">YES</span>
<span class="title">tcp_wrappers</span>=<span class="type">YES</span>
<span class="title">guest_enable</span>=<span class="type">YES</span>
<span class="title">guest_username</span>=opendoc
<span class="title">pam_service_name</span>=vsftpd.vu
<span class="title">user_config_dir</span>=/etc/vsftpd/vsftpd_user_conf
<span class="title">virtual_use_local_privs</span>=<span class="type">YES</span>
<span class="title">pasv_min_port</span>=<span class="number">50000</span>
<span class="title">pasv_max_port</span>=<span class="number">60000</span>
<span class="title">pasv_enable</span>=yes
<span class="title">max_clients</span>=<span class="number">200</span>
<span class="title">max_per_ip</span>=<span class="number">4</span>
<span class="title">idle_session_timeout</span>=<span class="number">600</span>
<span class="title">ftpd_banner</span>=<span class="type">Welcome</span> to opendoc <span class="type">FTP</span> service.
<span class="title">mkdir</span> /etc/vsftpd/vsftpd_user_conf
`&lt;/pre&gt;
# vi /etc/vsftpd/vsftpd_user_conf/ftpadmin 所有权限
&lt;pre&gt;`write_enable=<span class="type">YES</span>
<span class="title">anonymous_enable</span>=<span class="type">NO</span>
<span class="title">anon_world_readable_only</span>=<span class="type">NO</span>
<span class="title">anon_upload_enable</span>=<span class="type">YES</span>
<span class="title">anon_mkdir_write_enable</span>=<span class="type">YES</span>
<span class="title">anon_other_write_enable</span>=<span class="type">YES</span>
<span class="title">local_umask</span>=<span class="number">022</span>
<span class="title">download_enable</span>=<span class="type">Yes</span>
<span class="title">local_root</span>=/<span class="typedef"><span class="keyword">data</span></span>
`&lt;/pre&gt;
# vi /etc/vsftpd/vsftpd_user_conf/ftpuser 上传权限
&lt;pre&gt;`write_enable=<span class="type">YES</span>
<span class="title">anon_world_readable_only</span>=<span class="type">NO</span>
<span class="title">anon_upload_enable</span>=<span class="type">YES</span>
<span class="title">anon_mkdir_write_enable</span>=<span class="type">YES</span>
<span class="title">anon_other_write_enable</span>=<span class="type">YES</span>
<span class="title">local_umask</span>=<span class="number">022</span>
<span class="title">download_enable</span>=<span class="type">NO</span>
<span class="title">local_root</span>=/<span class="typedef"><span class="keyword">data</span></span>
`&lt;/pre&gt;
# vi /etc/vsftpd/vsftpd_user_conf/ftp 只能下载
&lt;pre&gt;`write_enable=<span class="type">NO</span>
<span class="title">anon_world_readable_only</span>=<span class="type">NO</span>
<span class="title">anon_upload_enable</span>=<span class="type">NO</span>
<span class="title">anon_mkdir_write_enable</span>=<span class="type">NO</span>
<span class="title">anon_other_write_enable</span>=<span class="type">NO</span>
<span class="title">local_umask</span>=<span class="number">022</span>
<span class="title">download_enable</span>=yes
<span class="title">local_root</span>=/<span class="typedef"><span class="keyword">data</span></span>
</pre></figure></code></pre>
<h1>/etc/init.d/vsftpd start</h1>
<p>Starting vsftpd for vsftpd: [ OK ]</p>
<p>测试：</p>
<h1>ftp -n localhost</h1>
<p>Connected to ifidc.
530 Please login with USER and PASS.
530 Please login with USER and PASS.
KERBEROS_V4 rejected as an authentication type
220 Welcome to tfhudong FTP service
ftp&gt; use ftpadmin
331 Please specify the password.
Password:
230 Login successful.
ftp&gt; quit
221 Goodbye.</p>
<h1>ftp -n localhost</h1>
<p>Connected to ifidc.
220 Welcome to tfhudong FTP service
530 Please login with USER and PASS.
530 Please login with USER and PASS.
KERBEROS_V4 rejected as an authentication type
ftp&gt; use ftpuser
331 Please specify the password.
Password:
230 Login successful.
ftp&gt; quit
221 Goodbye.</p>
<h1>ftp -n localhost</h1>
<p>Connected to ifidc.
220 Welcome to tfhudong FTP service
530 Please login with USER and PASS.
530 Please login with USER and PASS.
KERBEROS_V4 rejected as an authentication type
ftp&gt; use ftp
331 Please specify the password.
Password:
230 Login successful.
ftp&gt; quit
221 Goodbye.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/14/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/16/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:bubbyroom.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Monitoring/">Monitoring</a><small>1</small></li>
  
    <li><a href="/categories/Webserver/">Webserver</a><small>4</small></li>
  
    <li><a href="/categories/cdn/">cdn</a><small>12</small></li>
  
    <li><a href="/categories/faq/">faq</a><small>26</small></li>
  
    <li><a href="/categories/cdn/faq/">faq</a><small>1</small></li>
  
    <li><a href="/categories/faq/howtoforge/">howtoforge</a><small>1</small></li>
  
    <li><a href="/categories/howtoforge/">howtoforge</a><small>6</small></li>
  
    <li><a href="/categories/puppet/">puppet</a><small>2</small></li>
  
    <li><a href="/categories/cdn/puppet/">puppet</a><small>4</small></li>
  
    <li><a href="/categories/分布式监控/">分布式监控</a><small>1</small></li>
  
    <li><a href="/categories/cdn/分布式监控/">分布式监控</a><small>2</small></li>
  
    <li><a href="/categories/howtoforge/分布式监控/">分布式监控</a><small>2</small></li>
  
    <li><a href="/categories/应用程序/">应用程序</a><small>19</small></li>
  
    <li><a href="/categories/howtoforge/应用程序/">应用程序</a><small>2</small></li>
  
    <li><a href="/categories/数据库/">数据库</a><small>4</small></li>
  
    <li><a href="/categories/faq/数据库/">数据库</a><small>1</small></li>
  
    <li><a href="/categories/生活乐事/">生活乐事</a><small>3</small></li>
  
    <li><a href="/categories/程序开发/">程序开发</a><small>4</small></li>
  
    <li><a href="/categories/系统命令/">系统命令</a><small>14</small></li>
  
    <li><a href="/categories/faq/系统命令/">系统命令</a><small>2</small></li>
  
    <li><a href="/categories/美图鉴赏/">美图鉴赏</a><small>0</small></li>
  
    <li><a href="/categories/应用程序/负载均衡/">负载均衡</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Cache-control/" style="font-size: 16.75px;">Cache-control</a><a href="/tags/Cluster-bacst/" style="font-size: 12.00px;">Cluster-bacst</a><a href="/tags/Header-V3-DSA-signature/" style="font-size: 15.75px;">Header V3 DSA signature</a><a href="/tags/object-Object/" style="font-size: 14.75px;">[object Object]</a><a href="/tags/apache/" style="font-size: 19.50px;">apache</a><a href="/tags/awk/" style="font-size: 18.25px;">awk</a><a href="/tags/bash/" style="font-size: 17.00px;">bash</a><a href="/tags/browser/" style="font-size: 13.75px;">browser</a><a href="/tags/cache/" style="font-size: 14.00px;">cache</a><a href="/tags/cdn/" style="font-size: 16.25px;">cdn</a><a href="/tags/centos/" style="font-size: 19.25px;">centos</a><a href="/tags/cpan/" style="font-size: 12.75px;">cpan</a><a href="/tags/cpanm/" style="font-size: 12.25px;">cpanm</a><a href="/tags/etag/" style="font-size: 14.25px;">etag</a><a href="/tags/expires/" style="font-size: 13.00px;">expires</a><a href="/tags/foreman/" style="font-size: 15.25px;">foreman</a><a href="/tags/gzip/" style="font-size: 10.50px;">gzip</a><a href="/tags/libmemcached/" style="font-size: 15.00px;">libmemcached</a><a href="/tags/mod_cband/" style="font-size: 11.00px;">mod_cband</a><a href="/tags/mod_limitipconn/" style="font-size: 12.50px;">mod_limitipconn</a><a href="/tags/moudles/" style="font-size: 10.25px;">moudles</a><a href="/tags/mysql/" style="font-size: 18.75px;">mysql</a><a href="/tags/nginx/" style="font-size: 18.00px;">nginx</a><a href="/tags/php-1/" style="font-size: 16.50px;">php</a><a href="/tags/php-fpm/" style="font-size: 17.50px;">php-fpm</a><a href="/tags/puppet/" style="font-size: 19.00px;">puppet</a><a href="/tags/python26/" style="font-size: 15.50px;">python2.6</a><a href="/tags/referer/" style="font-size: 11.25px;">referer</a><a href="/tags/repo/" style="font-size: 16.00px;">repo</a><a href="/tags/ruby/" style="font-size: 14.50px;">ruby</a><a href="/tags/shell/" style="font-size: 17.25px;">shell</a><a href="/tags/shtml/" style="font-size: 11.50px;">shtml</a><a href="/tags/ssi/" style="font-size: 11.75px;">ssi</a><a href="/tags/tomcat/" style="font-size: 18.50px;">tomcat</a><a href="/tags/yum/" style="font-size: 19.75px;">yum</a><a href="/tags/单引号/" style="font-size: 13.25px;">单引号</a><a href="/tags/双引号/" style="font-size: 13.50px;">双引号</a><a href="/tags/环境变量/" style="font-size: 10.00px;">环境变量</a><a href="/tags/详解/" style="font-size: 17.75px;">详解</a><a href="/tags/过滤日志/" style="font-size: 10.75px;">过滤日志</a>
  </div>
</div>


  

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 Liu Yu
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>